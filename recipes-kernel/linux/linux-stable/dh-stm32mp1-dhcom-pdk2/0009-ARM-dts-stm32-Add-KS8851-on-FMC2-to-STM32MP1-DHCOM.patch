From b32f6cbe12a6ac0ce4a9bf6b694e63e9a6d7f3d5 Mon Sep 17 00:00:00 2001
From: Marek Vasut <marex@denx.de>
Date: Mon, 20 Jan 2020 19:34:23 +0100
Subject: [PATCH 09/13] ARM: dts: stm32: Add KS8851 on FMC2 to STM32MP1 DHCOM

Add bindings for the KS8851 ethernet present on the STM32MP1 DHCOM SoM.

Signed-off-by: Marek Vasut <marex@denx.de>
---
 arch/arm/boot/dts/stm32mp157c-dhcom-pdk2.dts |   1 +
 arch/arm/boot/dts/stm32mp157c-dhcom-som.dtsi | 103 +++++++++++++++++++
 2 files changed, 104 insertions(+)

diff --git a/arch/arm/boot/dts/stm32mp157c-dhcom-pdk2.dts b/arch/arm/boot/dts/stm32mp157c-dhcom-pdk2.dts
index 9428593ff702..e4cccbd75fad 100644
--- a/arch/arm/boot/dts/stm32mp157c-dhcom-pdk2.dts
+++ b/arch/arm/boot/dts/stm32mp157c-dhcom-pdk2.dts
@@ -15,6 +15,7 @@
 		serial1 = &usart3;
 		serial2 = &uart8;
 		ethernet0 = &ethernet0;
+		ethernet1 = &ksz8851;
 	};
 
 	chosen {
diff --git a/arch/arm/boot/dts/stm32mp157c-dhcom-som.dtsi b/arch/arm/boot/dts/stm32mp157c-dhcom-som.dtsi
index ee9ae7581b54..61c9b265357c 100644
--- a/arch/arm/boot/dts/stm32mp157c-dhcom-som.dtsi
+++ b/arch/arm/boot/dts/stm32mp157c-dhcom-som.dtsi
@@ -95,6 +95,52 @@
 	status = "okay";
 };
 
+&fmc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fmc_pins_b>;
+	pinctrl-1 = <&fmc_sleep_pins_b>;
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <1>;
+	/delete-property/interrupts;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	reg = <0x58002000 0x1000>;
+	ranges;
+
+	ebi {
+		#address-cells = <2>;
+		#size-cells = <1>;
+		compatible = "st,stm32mp1-fmc2-ebi";
+		ranges = <0 0 0x60000000 0x4000000>,
+			 <1 0 0x64000000 0x4000000>,
+			 <2 0 0x68000000 0x4000000>,
+			 <3 0 0x6c000000 0x4000000>;
+
+		ksz8851: ks8851mll@0,0 {
+			compatible = "micrel,ks8851-mll";
+			reg = <1 0x0 0x2 1 0x2 0x20000>;
+			interrupt-parent = <&gpioc>;
+			interrupts = <3 IRQ_TYPE_LEVEL_LOW>;
+			bank-width = <2>;
+
+			/* Timing values are in nS */
+			st,fmc2_ebi_cs_mux_enable;
+			st,fmc2_ebi_cs_transaction_type = <4>;
+			st,fmc2_ebi_cs_buswidth = <16>;
+			st,fmc2_ebi_cs_address_setup = <6>;
+			st,fmc2_ebi_cs_address_hold = <6>;
+			st,fmc2_ebi_cs_data_setup = <127>;
+			st,fmc2_ebi_cs_bus_turnaround = <9>;
+			st,fmc2_ebi_cs_data_hold = <9>;
+		};
+	};
+};
+
+&gpioc {
+	status = "okay";
+};
+
 &gpu {
 	status = "okay";
 };
@@ -283,6 +329,63 @@
 	status = "okay";
 };
 
+&pinctrl {
+	fmc_pins_b: fmc-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 4, AF12)>, /* FMC_NOE */
+				 <STM32_PINMUX('D', 5, AF12)>, /* FMC_NWE */
+				 <STM32_PINMUX('B', 7, AF12)>, /* FMC_NL */
+				 <STM32_PINMUX('D', 14, AF12)>, /* FMC_D0 */
+				 <STM32_PINMUX('D', 15, AF12)>, /* FMC_D1 */
+				 <STM32_PINMUX('D', 0, AF12)>, /* FMC_D2 */
+				 <STM32_PINMUX('D', 1, AF12)>, /* FMC_D3 */
+				 <STM32_PINMUX('E', 7, AF12)>, /* FMC_D4 */
+				 <STM32_PINMUX('E', 8, AF12)>, /* FMC_D5 */
+				 <STM32_PINMUX('E', 9, AF12)>, /* FMC_D6 */
+				 <STM32_PINMUX('E', 10, AF12)>, /* FMC_D7 */
+				 <STM32_PINMUX('E', 11, AF12)>, /* FMC_D8 */
+				 <STM32_PINMUX('E', 12, AF12)>, /* FMC_D9 */
+				 <STM32_PINMUX('E', 13, AF12)>, /* FMC_D10 */
+				 <STM32_PINMUX('E', 14, AF12)>, /* FMC_D11 */
+				 <STM32_PINMUX('E', 15, AF12)>, /* FMC_D12 */
+				 <STM32_PINMUX('D', 8, AF12)>, /* FMC_D13 */
+				 <STM32_PINMUX('D', 9, AF12)>, /* FMC_D14 */
+				 <STM32_PINMUX('D', 10, AF12)>, /* FMC_D15 */
+				 <STM32_PINMUX('G', 9, AF12)>, /* FMC_NE2_FMC_NCE */
+				 <STM32_PINMUX('G', 12, AF12)>; /* FMC_NE4 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+	};
+
+	fmc_sleep_pins_b: fmc-sleep-1 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, ANALOG)>, /* FMC_NOE */
+				 <STM32_PINMUX('D', 5, ANALOG)>, /* FMC_NWE */
+				 <STM32_PINMUX('B', 7, ANALOG)>, /* FMC_NL */
+				 <STM32_PINMUX('D', 14, ANALOG)>, /* FMC_D0 */
+				 <STM32_PINMUX('D', 15, ANALOG)>, /* FMC_D1 */
+				 <STM32_PINMUX('D', 0, ANALOG)>, /* FMC_D2 */
+				 <STM32_PINMUX('D', 1, ANALOG)>, /* FMC_D3 */
+				 <STM32_PINMUX('E', 7, ANALOG)>, /* FMC_D4 */
+				 <STM32_PINMUX('E', 8, ANALOG)>, /* FMC_D5 */
+				 <STM32_PINMUX('E', 9, ANALOG)>, /* FMC_D6 */
+				 <STM32_PINMUX('E', 10, ANALOG)>, /* FMC_D7 */
+				 <STM32_PINMUX('E', 11, ANALOG)>, /* FMC_D8 */
+				 <STM32_PINMUX('E', 12, ANALOG)>, /* FMC_D9 */
+				 <STM32_PINMUX('E', 13, ANALOG)>, /* FMC_D10 */
+				 <STM32_PINMUX('E', 14, ANALOG)>, /* FMC_D11 */
+				 <STM32_PINMUX('E', 15, ANALOG)>, /* FMC_D12 */
+				 <STM32_PINMUX('D', 8, ANALOG)>, /* FMC_D13 */
+				 <STM32_PINMUX('D', 9, ANALOG)>, /* FMC_D14 */
+				 <STM32_PINMUX('D', 10, ANALOG)>, /* FMC_D15 */
+				 <STM32_PINMUX('G', 9, ANALOG)>, /* FMC_NE2_FMC_NCE */
+				 <STM32_PINMUX('G', 12, ANALOG)>; /* FMC_NE4 */
+		};
+	};
+};
+
 &pwr_regulators {
 	vdd-supply = <&vdd>;
 	vdd_3v3_usbfs-supply = <&vdd_usb>;
-- 
2.25.1

